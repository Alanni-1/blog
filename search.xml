<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS 实现文本的单行和多行溢出省略效果</title>
      <link href="/blog/2021/07/28/fiw/"/>
      <url>/blog/2021/07/28/fiw/</url>
      
        <content type="html"><![CDATA[<h1 id="当行文本"><a href="#当行文本" class="headerlink" title="当行文本"></a>当行文本</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; </span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis; </span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>overflow: hidden</code>（文字长度超出限定宽度，则隐藏超出的内容）</li><li><code>white-space: nowrap</code>（设置文字在一行显示，不能换行）</li><li><code>text-overflow: ellipsis</code>（规定当文本溢出时，显示省略符号来代表被修剪的文本）</li></ul><h1 id="多行文本（css）"><a href="#多行文本（css）" class="headerlink" title="多行文本（css）"></a>多行文本（css）</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">   -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>-webkit-line-clamp: 2</code>（用来限制在一个块元素显示的文本的行数, 2 表示最多显示 2 行。为了实现该效果，它需要组合其他的WebKit属性）</li><li><code>display: -webkit-box</code>（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）</li><li><code>-webkit-box-orient: vertical</code>（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）</li><li><code>overflow: hidden</code>（文本溢出限定的宽度就隐藏内容）</li><li><code>text-overflow: ellipsis</code>（多行文本的情况下，用省略号“…”隐藏溢出范围的文本)</li></ul><h1 id="多行文本（js）"><a href="#多行文本（js）" class="headerlink" title="多行文本（js）"></a>多行文本（js）</h1><ul><li>监听DOM尺寸变化</li><li>判断是否溢出 scrollHeight &gt; offsetHeight</li><li>二分查找多行截取字符临界值（算法的解法：判断字符串是否溢出，二分查找字符串溢出临界子串，控制…显示）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 如何实现多行文本展开收起效果</title>
      <link href="/blog/2021/07/28/forw/"/>
      <url>/blog/2021/07/28/forw/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img src="https://alanni-1.github.io/blog/img/forw/01.png"></p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="https://alanni-1.github.io/blog/img/forw/02.gif"></p><hr><p>主要难点：</p><ul><li>如何实现 <code>展开</code> 和 <code>收起</code> 切换按钮的文字环绕效果</li><li>如何实现<code>多行文本溢出省略</code>效果</li><li>如何实现 <code>展开</code> 和 <code>收起</code> 的状态or文字切换</li></ul><p>初始html：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>展开<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    但听得蹄声如雷，十余乘马疾风般卷上山来。马上乘客一色都是玄色薄毡大氅，</span><br><span class="line">    里面玄色布衣，但见人似虎，马如龙，人既矫捷，马亦雄骏，每一匹马都是高头</span><br><span class="line">    长腿，通体黑毛，奔到近处，群雄眼前一亮，金光闪闪，却见每匹马的蹄铁竟然</span><br><span class="line">    是黄金打就。来者一共是一十九骑，人数虽不甚多，气势之壮，却似有如千军万</span><br><span class="line">    马一般，前面一十八骑奔到近处，拉马向两旁一分，最后一骑从中驰出<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.text</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">475px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: aqua solid <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: dodgerblue;</span></span><br><span class="line"><span class="css">    <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/forw/03.png"></p><h1 id="一、控制按钮文字环绕效果"><a href="#一、控制按钮文字环绕效果" class="headerlink" title="一、控制按钮文字环绕效果"></a>一、控制按钮文字环绕效果</h1><p>一般展开、收起按钮都在文字的右下脚：</p><ul><li>居右：<code>float: right</code></li><li>居下：<code>margin-top</code></li></ul><p>但 <code>margin</code> 虽然可以将按钮局下，但它无法实现文字环绕效果，所以我们这里利用伪元素实现：</p><ul><li>居右：<code>float: right</code></li><li>居下：<code>.text::before</code></li></ul><div class="note info no-icon flat"><p>居右</p></div><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/forw/04.png"></p><div class="note info no-icon flat"><p>居左</p></div><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现出现了高度塌陷（ <code>calc(100% - 20px)</code> 无效）的问题：</p><div class="note warning no-icon flat"><p>由于包含块的高度没有显式指定，并且该元素不是绝对定位，则计算值伪 auto，auto * 100/100 = NaN</p><p>— CSS 世界</p></div><p>此时解决办法有：</p><ul><li>设置显式的高度值：这里高度是动态的，没办法显式指定，所以此方法不可用❌</li><li>如果包含块的高度显式指定，则设置该元素为绝对定位：包含块的高度是动态的，没办法显式指定，所以此方法也不可用❌</li><li>在元素外边包一层具有包裹性又具有定位特性的标签：✅</li></ul><p>这里包一层 flex 布局。因为在 flex 布局的子项中，可以通过百分比来计算变化高度，因此，这里需要给  <code>.text</code> 包裹一层，然后设置 <code>display: flex</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;exp&quot;</span>&gt;</span>展开<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">     但听得蹄声如雷，十余乘马疾风般卷上山来。马上乘客一色都是玄色薄毡大氅，</span><br><span class="line">     里面玄色布衣，但见人似虎，马如龙，人既矫捷，马亦雄骏，每一匹马都是高头</span><br><span class="line">     长腿，通体黑毛，奔到近处，群雄眼前一亮，金光闪闪，却见每匹马的蹄铁竟然</span><br><span class="line">     是黄金打就。来者一共是一十九骑，人数虽不甚多，气势之壮，却似有如千军万</span><br><span class="line">     马一般，前面一十八骑奔到近处，拉马向两旁一分，最后一骑从中驰出<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"> <span class="selector-class">.content</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.text</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">   <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">   <span class="attribute">float</span>: right;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: -<span class="number">20px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.btn</span> &#123;</span><br><span class="line">   <span class="attribute">float</span>: right;</span><br><span class="line">   <span class="attribute">clear</span>: both;</span><br><span class="line">   <span class="attribute">margin-right</span>: <span class="number">8px</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/forw/05.png"></p><h1 id="二、多行文本溢出省略效果"><a href="#二、多行文本溢出省略效果" class="headerlink" title="二、多行文本溢出省略效果"></a>二、多行文本溢出省略效果</h1><p>我们在 <a href="https://alanni-1.github.io/blog/2021/07/28/fiw/">CSS 实现文本的单行和多行溢出省略效果</a> 介绍过：</p><p><strong>多行文本（css）</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  -webkit-line-clamp: <span class="number">3</span>;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>-webkit-line-clamp: 3</code>（用来限制在一个块元素显示的文本的行数, 2 表示最多显示 2 行。为了实现该效果，它需要组合其他的WebKit属性）</li><li><code>display: -webkit-box</code>（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）</li><li><code>-webkit-box-orient: vertical</code>（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）</li><li><code>overflow: hidden</code>（文本溢出限定的宽度就隐藏内容）</li><li><code>text-overflow: ellipsis</code>（多行文本的情况下，用省略号“…”隐藏溢出范围的文本)</li></ul><p><img src="https://alanni-1.github.io/blog/img/forw/06.png"></p><h1 id="三、如何实现-展开-和-收起-的状态切换"><a href="#三、如何实现-展开-和-收起-的状态切换" class="headerlink" title="三、如何实现 展开 和 收起 的状态切换"></a>三、如何实现 <code>展开</code> 和 <code>收起</code> 的状态切换</h1><p>使用 <code>input type=&quot;checkbox&quot;</code> 控制展开与收起效果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;exp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#exp</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">visibility</span>: hidden;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#exp</span><span class="selector-pseudo">:checked</span>+<span class="selector-class">.text</span>&#123;</span></span><br><span class="line"><span class="css">    -webkit-line-clamp: <span class="number">999</span>; <span class="comment">/*设置一个足够大的行数就可以了*/</span></span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/forw/07.png"></p><p>但文字展开后控制按钮依然显示 <code>展开</code> ，应该显示 <code>收起</code> 才对</p><p>这里使用伪类生成技术，具体做法就是去除或者隐藏按钮里面的文字，采用伪元素生成</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;exp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.btn</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&#x27;展开&#x27;</span></span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#exp</span><span class="selector-pseudo">:checked</span>+<span class="selector-class">.text</span> <span class="selector-class">.btn</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&#x27;收起&#x27;</span></span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终，大功告成：</p><p><img src="https://alanni-1.github.io/blog/img/forw/02.gif"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 margin 塌陷和 margin 合并及其解决方案</title>
      <link href="/blog/2021/07/17/three/"/>
      <url>/blog/2021/07/17/three/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>小问题总是被人们视而不见，等到遇到的时候又突然想不起来，无从下手，所以我们需要经常总结，这样可以帮助我们更好的记忆东西。今天我们总结两个不起眼的小问题：<code>margin</code> 塌陷和 <code>margin</code> 合并。</p><h1 id="margin-塌陷"><a href="#margin-塌陷" class="headerlink" title="margin 塌陷"></a>margin 塌陷</h1><h2 id="什么是-margin-塌陷"><a href="#什么是-margin-塌陷" class="headerlink" title="什么是 margin 塌陷"></a>什么是 margin 塌陷</h2><p>我们先来举个例子，然后引出什么是 <code>margin</code> 塌陷</p><p>需求：在父元素中，通过 <code>margin</code> 让父元素相对左边及顶部距离<code>100px</code>，也让子元素相对于父元素左边和顶部各<code>50px</code>。</p><p><strong>代码如下：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">219</span>, <span class="number">68</span>, <span class="number">101</span>);</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.father</span> <span class="selector-tag">div</span><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">56</span>, <span class="number">248</span>, <span class="number">207</span>);</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码看上去没有什么问题，看下效果</strong></p><p><img src="https://alanni-1.github.io/blog/img/three/01.png"></p><p>惊奇的发现，结果出乎我们意料！水平方向的距离确实没问题，但是垂直方向上，明明子元素设置了<code>margin-top</code>距离顶部<code>50px</code>，按道理它会距离父元素顶部<code>50px</code>才对。</p><p>这种现象被称之为<code>margin</code>塌陷。但很多人可能都不太理解，为什么叫它塌陷？其实你可以这样理解，如上述例子，原本子元素要距离父元素顶部<code>50px</code>，现在没有了，也就是父元素的顶棚对子元素来说没有作用，相当于没有，相当于塌陷下来了。所以叫margin塌陷。</p><p>一句话总结：父子嵌套的元素垂直方向的<code>margin</code>取最大值。</p><p>但是有的时候我们不希望有这样的问题，那我们如何解决<code>margin</code>塌陷的问题呢？</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="什么是BFC和作用"><a href="#什么是BFC和作用" class="headerlink" title="什么是BFC和作用"></a>什么是BFC和作用</h3><p><code>Block Formatting Context</code>，中文叫块级格式上下文。</p><p><code>CSS</code>将<code>HTML</code>的每一个元素都当成一个盒子，而且它进一步的认为每一个盒子里面都有一套正常的语法规则或者叫渲染规则，它能根据这个规则将写的HTML元素绘制出来，但是我们可以通过一些特定的手段触发<code>BFC</code>，让其所符合的语法规则和原来的语法规则有点不一样。</p><p>也就是触发<code>BFC</code>之后，特定的盒子会遵循另一套语法规则。</p><p><code>BFC</code>听起来挺神奇，能改变一个盒子的语法规则，那到底改变了多少呢，其实也没改变多少。可能千分之一都不到。也就是它只改变了一点点。但是就是这一点点它把解决了<code>margin</code>塌陷和<code>margin</code>合并的问题</p><h3 id="如何触发BFC"><a href="#如何触发BFC" class="headerlink" title="如何触发BFC"></a>如何触发BFC</h3><p>小结触发<code>BFC</code>方法：</p><ol><li><code>float</code>属性为<code>left</code>/<code>right</code></li><li><code>overflow</code>为<code>hidden</code>/<code>scroll</code>/<code>auto</code></li><li><code>position</code>为<code>absolute</code>/<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>/<code>table-cell</code>/<code>table-caption</code></li></ol><p>有些人会想，有这几多方式触发<code>BFC</code>，那用哪种方式好一些？看具体情况，个人认为一个原则：<strong>针对需求，看哪个触发方式没有影响就用那个</strong></p><h2 id="解决margin塌陷的问题"><a href="#解决margin塌陷的问题" class="headerlink" title="解决margin塌陷的问题"></a>解决margin塌陷的问题</h2><p><strong>如下通过<code>overflow: hidden</code>触发<code>bfc</code></strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">219</span>, <span class="number">68</span>, <span class="number">101</span>);</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;<span class="comment">/* 触发bfc */</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.father</span> <span class="selector-tag">div</span><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">56</span>, <span class="number">248</span>, <span class="number">207</span>);</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下</strong></p><p><img src="https://alanni-1.github.io/blog/img/three/02.png"></p><p><strong>问题已经解决！</strong></p><h1 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h1><h2 id="什么是margin合并"><a href="#什么是margin合并" class="headerlink" title="什么是margin合并"></a>什么是margin合并</h2><p>还是来看个例子，把两个兄弟块元素，一个设置下外边距100px，一个设置上外边距100px，让两个元素相距200px。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下</strong></p><p><img src="https://alanni-1.github.io/blog/img/three/03.png"></p><p>我们发现这两个元素之间，他们的<code>margin-bottom</code>和<code>margin-top</code>合并了，并且显示的是较大值。这种现象被称为<code>margin</code>合并。解决的方式也是通过触发<code>bfc</code>来解决</p><h2 id="解决margin合并"><a href="#解决margin合并" class="headerlink" title="解决margin合并"></a>解决margin合并</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">    <span class="comment">/* 触发bfc */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.two</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下</strong></p><p><img src="https://alanni-1.github.io/blog/img/three/04.png"></p><p><strong>解决问题！但是一般不这么解决，为什么？</strong></p><p>因为<code>margin</code>合并和<code>margin</code>塌陷不一样，<code>margin</code>塌陷只添加了<code>CSS</code>，<code>margin</code>合并除了添加<code>CSS</code>，还修改了<code>HTML</code>结构。我们知道一般html结构是不能乱改动的，所以我们通过数学计算来解决这各<code>margin</code>合并的问题。比如上面的例子，我们只要设置前面元素的<code>margin-bottom</code>为<code>200px</code>或者后面元素的<code>margin-top</code>为<code>200px</code>即可，如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.one</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是关于<code>margin</code>塌陷和<code>margin</code>合并的小结，如有问题烦请留言告知</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue/React列表组件中的key作用是什么？</title>
      <link href="/blog/2021/07/16/twe/"/>
      <url>/blog/2021/07/16/twe/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue中的key"><a href="#Vue中的key" class="headerlink" title="Vue中的key"></a>Vue中的key</h2><p>在使用Vue开发项目中，如果使用循环渲染<code>没有使用key</code>的时候，<code>vue会警告</code>。但是这个key的作用是什么。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在Vue官网中提到</p><blockquote><p>建议尽可能在使用 v-for 时提供 kye，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。因为它是Vue识别节点的一个通用机制，key并不与 v-for 特别关联。</p><p>用 key 管理可复用的元素，Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外。</p></blockquote><p>通过上诉可以大致了解 key 可以使 Vue 在复用时快速高效的渲染元素。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Vue在渲染列表的时候采用<code>就地复用</code>的原则,如果改变了dom的顺序，那么vue不会对dom元素的顺序做修改,而是就此复用当前的元素</p><p><strong>假设我们要在BC之间插入一个元素,如图所示</strong></p><p><img src="https://alanni-1.github.io/blog/img/twe/01.png"></p><p><strong>如果我们<code>没有设置key</code>的值那么 Vue 就会把整个列表<code>重新渲染一变</code>，得到如图结果</strong></p><p><img src="https://alanni-1.github.io/blog/img/twe/02.png"></p><p><strong>要是我们<code>添加了key</code>的话 Vue 会通过对先前 key 值配对的属性<code>不会重新渲染</code>一次</strong>，如图（左边没设置key，右边设置了key）</p><p><img src="https://alanni-1.github.io/blog/img/twe/03.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3> <div class="note warning flat"><p>key 值是唯一的，建议不要设置 index 为key值，导致的问题就是以前的数据和重新渲染后的数据随着 key 值的变化从而没法建立关联关系. 这就失去了 key 值存在的意义. 也是导致数据出现诡异的罪魁祸首!</p></div><p>Vue是不直接操作DOM的，是通过js的Object对象来模拟DOM中的节点，比较虚拟DOM是用的diff的算法。在同级A,B,C,D四个节点中，在B和C之间插入E,<strong>没有key的时候</strong>：C更新成了E，D更新成了C，最后插入D，这样效率很低。<br><strong>加上key之后</strong>，就能准确的找到节点的位置：发现ABCD都没变化，直接插入E就可以了。<br>所以<strong>key的作用主要是为了高效的更新虚拟DOM</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list：[</span><br><span class="line">&#123;</span><br><span class="line">id: 1,</span><br><span class="line">name: &#x27;a&#x27;,</span><br><span class="line">//index: 0</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: 2,</span><br><span class="line">name: &#x27;b&#x27;,</span><br><span class="line">//index: 1</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: 3,</span><br><span class="line">name: &#x27;c&#x27;,</span><br><span class="line">//index: 2</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: 4,</span><br><span class="line">name: &#x27;d&#x27;,</span><br><span class="line">//index: 3</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如上面的一串数组a，b，c，d，如果在b，c中间插入一个e</p><p><strong>如果 key 绑定的是 index</strong> ；</p><p>那么除了a，b没有被改变之外，c，d的index发生了变化，所以c和d也都要重新渲染一遍，<strong>影响了性能</strong>。</p><p>原理如图：</p><p><img src="https://alanni-1.github.io/blog/img/twe/03.png"></p><h2 id="React中的key"><a href="#React中的key" class="headerlink" title="React中的key"></a>React中的key</h2><p>React中如果没有指定 key 也会<code>进行警告</code>，和 Vue 为了提升渲染性能，在内部维持了一个虚拟dom，当渲染结构有所变化的时候，会在虚拟dom中先用diff算法先进行一次对比，将所有的差异化解决之后，再一次性根据虚拟dom的变化，渲染到真实的dom结构中。</p><div class="note info flat"><p>key值是唯一的不建议使用 index 值。原理同上</p></div><p>简单示例，了解一下。等同于 Vue </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import React, &#123;Component&#125; from &#x27;react&#x27;;</span><br><span class="line">class Test extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            testArray: [&#123;text: &#x27;组件1&#x27;, id: &#x27;a&#x27;&#125;, &#123;text: &#x27;组件2&#x27;, id: &#x27;b&#x27;&#125;, &#123;text: &#x27;组件3&#x27;, id: &#x27;c&#x27;&#125;, &#123;text: &#x27;组件4&#x27;, id: &#x27;d&#x27;&#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //修改state打乱顺序</span><br><span class="line">    sort()&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            testArray: [&#123;text: &#x27;组件1&#x27;, id: &#x27;a&#x27;&#125;, &#123;text: &#x27;组件3&#x27;, id: &#x27;c&#x27;&#125;, &#123;text: &#x27;组件2&#x27;, id: &#x27;b&#x27;&#125;, &#123;text: &#x27;组件4&#x27;, id: &#x27;d&#x27;&#125;]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;div&gt;不指定key属性&lt;/div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.state.testArray.map((item) =&gt; &#123;</span><br><span class="line">                        return &lt;li &gt;&lt;span&gt;&#123;item.text&#125;&lt;/span&gt;&lt;input/&gt;&lt;/li&gt;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;div&gt;指定key属性&lt;/div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.state.testArray.map((item) =&gt; &#123;</span><br><span class="line">                        return &lt;li key=&#123;item.id&#125;&gt;&lt;span&gt;&#123;item.text&#125;&lt;/span&gt;&lt;input/&gt;&lt;/li&gt;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;button onClick=&#123;::this.sort&#125;&gt;打乱排序&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">export default Test</span><br></pre></td></tr></table></figure><p><strong>打乱前在iput中填入相应内容</strong></p><p><img src="https://alanni-1.github.io/blog/img/twe/04.png"></p><p><strong>打乱顺序后</strong></p><p><img src="https://alanni-1.github.io/blog/img/twe/05.png"></p><p>我们可以观察一下，打乱顺序后，如果我们不指定key属性，列表中组件的标题打乱了，但是 input 里面的内容还是没有变，这是因为没有指定 key 打乱标题后重新对标题进行的渲染赋值。而指定了 kye 值且是<code>唯一的</code>时，React通过diff算法会根据 key 来进行匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var、let和const 的区别和实现原理</title>
      <link href="/blog/2021/07/15/one/"/>
      <url>/blog/2021/07/15/one/</url>
      
        <content type="html"><![CDATA[<p>es6里面新增了两个声明变量的方法，一个是let，用于声明变量。一个是const，用于声明常量。var、let和const的区别经常会被面试官问到，大多数人都可能回答的是作用域和变量提升这两方面的不同，但你们知道内在原理吗？</p><p>下面我们就从<code>声明过程</code>、<code>内存分配</code>和<code>变量提升</code>三个方面来看一下这三者之间的区别。</p><h2 id="声明过程"><a href="#声明过程" class="headerlink" title="声明过程"></a>声明过程</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>遇到有var的作用域,在任何语句执行前都已经完成了<code>声明和初始化</code>，也就是变量提升而且拿到undefined的原因由来。</p><div class="note primary modern"><p>通过下面示例可以看到变量a的声明跑到console.log的前面去了，只是赋值还是在console.log之后进行赋值的，console.log得到的结果就是undefined. 这就是所谓的变量提升了。</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量提升后</span></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">// 声明并初始化</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a未赋值返回undefined</span></span><br><span class="line">a = <span class="number">10</span>; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>解析器进入一个<code>块级作用域</code>,发现let关键字，变量<code>只是先完成声明</code>,并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是<code>暂时性死区</code>的由来。等到解析到有let那一行的时候,才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行。</p><div class="note danger flat"><p>let初始化赋值之前访问，就会报错未定义变量</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const、class都是同let—样的道理。const声明的是一个常量，常量是<code>不可修改</code>的，在没有完成初始化和赋值操作是访问会报错，<code>不能重复声明</code>同一个常量。</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="var-1"><a href="#var-1" class="headerlink" title="var"></a>var</h3><p>var的话，会直接在栈内存里预分配内存空间,然后等到实际语句执行的时候,再存储对应的变量,如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针</p><h3 id="let-1"><a href="#let-1" class="headerlink" title="let"></a>let</h3><p>let的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时,做一个检查,如果已经有相同变量名存在就会报错 Identifier ‘变量’ has already been declared</p><div class="note danger flat"><p>如果用let重复声明同一个变量，那么这时候就会报错：变量b已经被声明了</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;<span class="comment">//error : Identifier &#x27;b&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h3 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h3><p>const的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是<code>不可修改</code>的，对于基本类型来说你无法修改定义的值,对于引用类型来说你无法修改栈内存里分配的指针,但是你可以修改指针指向的对象里面的属性</p><div class="note danger flat"><p>const声明的常量是不可以直接更改的，一旦你尝试着去修改一个常量的时候，浏览器就会告诉你，常量不可以被修改！</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">3.1415926</span>;</span><br><span class="line">c = <span class="number">123</span>;<span class="comment">//error : Assignment to constant variable</span></span><br></pre></td></tr></table></figure><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>let const和var三者其实会存在变量提升</p><p>let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。</p><p>var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined</p><p>function的创建、初始化、赋值都被提升了</p><div class="note info modern"><p>function：声明、初始化、赋值一开始就全部完成,所以函数的变量提升优先级更高。</p></div>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2021/06/04/hello-world/"/>
      <url>/blog/2021/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
