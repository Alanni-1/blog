<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>都2022年了,你总不能还只会 npm i 吧?</title>
      <link href="/blog/2022/05/18/b4ac0e5/"/>
      <url>/blog/2022/05/18/b4ac0e5/</url>
      
        <content type="html"><![CDATA[<h1 id="给喜欢的包加星-类似-github-的-star"><a href="#给喜欢的包加星-类似-github-的-star" class="headerlink" title="给喜欢的包加星(类似 github 的 star)"></a>给喜欢的包加星(类似 github 的 star)</h1><p>其实我把加星就当作是收藏的操作，其实在 npm 中它就是收藏的作用，因为在官网中，我们并不能像 github 一样清楚的看到这个仓库有多少颗 star。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm star [package-name]</span><br></pre></td></tr></table></figure><p>取消收藏</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm unstar [package-name]</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/01.png"></p><p>查看收藏列表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm stars</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/02.png"></p><p>这些操作都会报出在你的账号下，所以很方便。不用担心本机操作后其他地方看不到。你只需要有一个 npm 账户就可以了</p><h1 id="登录-npm"><a href="#登录-npm" class="headerlink" title="登录 npm"></a>登录 npm</h1><p>首先你要有一个 npm 的账号，没有的在👉<a href="https://www.npmjs.com/">npm 官网</a>注册一个就行了。</p><div class="note info modern"><p>注意:在官网注册的账号，登陆时使用淘宝源会报错，要改回默认源</p></div><p>推荐使用 nrm 或者 yrm 来快速切换镜像源,个人推荐使用 yrm,为什么呢?看下图</p><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/03.png"></p><p>yrm 会同时将你的 npm 和 yarn 一起切换,并且 ls 后会有*号标注当前正在使用的源,记得 nrm 以前也有的,现在不知道怎么了…</p><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/04.png"></p><p>当然你可以手动 npm 切换为默认源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><p>然后执行命令<code>npm login</code>,依次填写用户名、密码、邮箱即可。如果你在 npmjs 站点还设置了其他保护，就还需要输入一些验证码之类的等等…</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm adduser</span><br><span class="line"># or</span><br><span class="line">npm login</span><br><span class="line"># login是adduser的一个别名</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/05.png"></p><p>你可以通过以下命令查看当前 npm 的登陆人</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm whoami</span><br></pre></td></tr></table></figure><h1 id="查看某个包的文档"><a href="#查看某个包的文档" class="headerlink" title="查看某个包的文档"></a>查看某个包的文档</h1><p>每次我们想在浏览器中打开某个包的文档，总习惯去搜索引擎搜索，其实一行命令就能解决的事情,不要再去百度搜索啦~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 此命令会尝试猜测包文档 URL 的可能位置，一般没有自定义的话，就会打开包的github地址。</span><br><span class="line">npm docs [package-name]</span><br><span class="line"># or</span><br><span class="line">npm home [package-name]</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/06.gif"></p><p>尝试以下命令，可以快速打开 lodash 的官方文档 👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm docs lodash</span><br><span class="line"># or</span><br><span class="line">npm home lodash</span><br></pre></td></tr></table></figure><p><code>npm docs</code>或者<code>npm home</code>命令在不接参数时，会在当前项目中，通过 <code>package.json</code> 文件中的<code>homepage</code>配置，来打开对应的地址。</p><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/07.png"></p><p>如上图所示，其原理就是：当你要查看的项目中的 <code>package.json</code> 文件中，设置了<code>homepage</code>属性，通过<code>npm docs/home</code>就能打开对应的主页，没有设置<code>homepage</code>属性时，npm 会继续寻找其中的<code>repository</code>属性，这时候打开的就是项目在 github 中的托管地址 url 拼接“#readme” (例如：<a href="https://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D#readme)%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%60repository%60%E5%B1%9E%E6%80%A7%E4%B9%9F%E6%B2%A1%E8%AE%BE%E7%BD%AE%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E4%BC%9A%E6%89%93%E5%BC%80">https://github.com/用户名/仓库名#readme)，如果你`repository`属性也没设置，那么就会打开</a> npm 官网中包的所在地址，（例如：<a href="https://www.npmjs.com/package/npm-limit%EF%BC%89">https://www.npmjs.com/package/npm-limit）</a></p><p>当然，你也可以在<code>npm docs/home</code>后不接参数，这样就会直接打开当前项目的主页。</p><h1 id="查看某个包的代码仓库"><a href="#查看某个包的代码仓库" class="headerlink" title="查看某个包的代码仓库"></a>查看某个包的代码仓库</h1><p>想看某个包的源码?还要跑到 github 去搜索?nonono,也是一行代码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 此命令尝试猜测包的存储库 URL 的可能位置</span><br><span class="line">npm repo [package-name]</span><br></pre></td></tr></table></figure><p>👆 它是根据项目中的 <code>package.json</code> 文件中，设置的<code>repository</code>属性，来打开对应的 url。</p><h1 id="快速给一个包提问题"><a href="#快速给一个包提问题" class="headerlink" title="快速给一个包提问题"></a>快速给一个包提问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm bugs [package-name]</span><br></pre></td></tr></table></figure><p>👆 它是根据项目中的 <code>package.json</code> 文件中，设置的<code>bugs</code>属性，来打开对应的 url。</p><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/08.png"></p><h1 id="查看某个包的详细信息"><a href="#查看某个包的详细信息" class="headerlink" title="查看某个包的详细信息"></a>查看某个包的详细信息</h1><p>这个命令有什么用呢？可以很方便的看到指定包的详细信息，比如我们想找到包的作者以及 ta 的联系方式（交流学习）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm v [package-name]</span><br><span class="line"># or</span><br><span class="line">npm view [package-name]</span><br><span class="line">npm info [package-name]</span><br><span class="line">npm show [package-name]</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/09.png"></p><h1 id="查看某个包的所有历史版本"><a href="#查看某个包的所有历史版本" class="headerlink" title="查看某个包的所有历史版本"></a>查看某个包的所有历史版本</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm v [package-name] versions</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/10.png"></p><h1 id="本地开发的-npm-包如何调试"><a href="#本地开发的-npm-包如何调试" class="headerlink" title="本地开发的 npm 包如何调试"></a>本地开发的 npm 包如何调试</h1><p>我们可以像往常一样将本地开发的 npm 包安装到全局或指定目录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install . -g</span><br><span class="line"># 在某个项目中安装本地包</span><br><span class="line">npm install ../Path/xxPackageName</span><br></pre></td></tr></table></figure><p>也可以做一个软链指向当前需要调试的项目(全局)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>将调试包链接到当前项目中（先做一个软链指向当前需要调试的项目）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先在本地开发的 npm 包中执行👇</span><br><span class="line">npm link</span><br><span class="line"># 然后切换到你要安装本地调试包的项目中，执行👇，即可将本地包安装到项目依赖中</span><br><span class="line">npm link &lt;package-name&gt;</span><br><span class="line"></span><br><span class="line"># 项目中取消安装本地的调试包👇</span><br><span class="line">npm unlink &lt;package-name&gt;</span><br></pre></td></tr></table></figure><h1 id="npm-发布包"><a href="#npm-发布包" class="headerlink" title="npm 发布包"></a>npm 发布包</h1><p>首先，你得在本地登录（不会的看文章最开头的登录方法 👆）</p><p>登录完成后，发布自己开发的工具包，只需简单的三步！</p><div class="note info modern"><p>注意:使用淘宝源会报错，要改回默认源</p></div><p>记得每次发布前，修改下版本号！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm version [版本号]</span><br></pre></td></tr></table></figure><p>然后当前目录执行<code>npm publish</code>就好了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><h1 id="弃用包的相关操作"><a href="#弃用包的相关操作" class="headerlink" title="弃用包的相关操作"></a>弃用包的相关操作</h1><div class="note info modern"><p>注意：强烈建议弃用包或包版本而不是取消发布它们，因为取消发布会从注册表中完全删除一个包，这意味着任何依赖它的人都将无法再使用它，而不会发出警告。</p></div><p>弃用整个包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm deprecate package-name &quot;弃用信息&quot;</span><br></pre></td></tr></table></figure><p>弃用包的单个版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm deprecate package-name@version &quot;弃用信息&quot;</span><br></pre></td></tr></table></figure><p>取消弃用操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将弃用消息改为空字符串即可</span><br><span class="line">npm deprecate package-name &quot;&quot;</span><br></pre></td></tr></table></figure><p>取消发布（危险操作）*</p><p>取消发布整个包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm unpublish [package-name] -f</span><br></pre></td></tr></table></figure><p>取消发布包的指定版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm unpublish [package-name]@&lt;version&gt;</span><br></pre></td></tr></table></figure><div class="note info modern"><p>取消发布包后，以相同名称重新发布将被阻止 24 小时。如果您错误地取消发布了一个包，我们建议您以不同的名称再次发布，或者对于未发布的版本，增加版本号并再次发布。</p></div><h1 id="一些好用的其他操作"><a href="#一些好用的其他操作" class="headerlink" title="一些好用的其他操作"></a>一些好用的其他操作</h1><p>查看当前项目中有哪些包过时了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure><p>查看本地全局环境的包有哪些过时了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm outdated -g --depth=0</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/11.png"></p><p>列出 node_modules 中的所有包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ls node_modules</span><br><span class="line"># or</span><br><span class="line">npm dir node_modules</span><br></pre></td></tr></table></figure><p>审计项目中所有包的安全漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm audit</span><br><span class="line"># 这个命令依赖 package-lock.json 文件,所以如果你用的是yarn需要使用下面的命令</span><br><span class="line">yarn audit</span><br></pre></td></tr></table></figure><p>执行后会列出有问题的包</p><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/12.png"></p><table><thead><tr><th>hahh</th><th>hah</th></tr></thead><tbody><tr><td>Critical</td><td>需要立即解决的!</td></tr><tr><td>High</td><td>需要尽快解决!</td></tr><tr><td>Moderate</td><td>在时间允许的情况下解决</td></tr><tr><td>Low</td><td>随便你,不慌不燥不急不忙</td></tr></tbody></table><p>报告中会给出它问题的严重性,你就可以根据具体情况来进行版本更新或是调整。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm token list</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/13.png"></p><p>检测一下当前镜像源的延迟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ping</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/14.png"></p><p>检测当前 node 和 npm 存在的问题 👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm doctor</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/b4ac0e5/15.png"></p>]]></content>
      
      
      <categories>
          
          <category> 每天学点小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4个你需要了解的CSS 函数</title>
      <link href="/blog/2022/05/11/8d3432c/"/>
      <url>/blog/2022/05/11/8d3432c/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-函数"><a href="#CSS-函数" class="headerlink" title="CSS 函数"></a><strong>CSS 函数</strong></h1><p>CSS 函数用作各种 CSS 属性的值。所以基本上我们用它来评估一些 CSS 值。让我们看看其中的一些功能。</p><h1 id="attr"><a href="#attr" class="headerlink" title="attr()"></a><strong>attr()</strong></h1><p>此函数用于访问元素属性的值。让我们通过例子来理解它。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---- html ---</span><br><span class="line">&lt;div data-bg=&quot;black&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">--- css ---</span><br><span class="line">div &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">backgound: arrt(data-bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到我们有一个“div”和一个“data-bg”自定义属性，现在我可以使用 attr() 在 CSS 中访问它的值。所以，这就是你可以做很多有趣的事情的方式。</p><p>所以输出将是这样的。</p><p><img src="https://alanni-1.github.io/blog/img/8d3432c/01.png"></p><h1 id="calc"><a href="#calc" class="headerlink" title="calc()"></a><strong>calc()</strong></h1><p>在 attr() 之后我们有 calc()。顾名思义，它有助于执行 CSS 值的计算。当我们想要进行精确计算时，这可能很有用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- html ---</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">--- css ---</span><br><span class="line">.box &#123;</span><br><span class="line">width: calc(100px * 5 - 50px);</span><br><span class="line">height: calc(100px - 30px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我使用 calc() 来设置 div 的宽度和高度。</p><p><img src="https://alanni-1.github.io/blog/img/8d3432c/02.png"></p><h1 id="max"><a href="#max" class="headerlink" title="max()"></a><strong>max()</strong></h1><p>然后我们有 max()，它需要两个值并使用该 CSS 属性的最大值。这对于制作响应式宽度和高度很有用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- html ---</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">--- css ---</span><br><span class="line">.box &#123;</span><br><span class="line">width: max(50%, 500px);</span><br><span class="line">height: max(60%, 300px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，div 将具有最大可能的宽度和高度，如果 50% 大于 500px，则其宽度将为 50%，否则为 500px，高度也是一样。</p><h1 id="min"><a href="#min" class="headerlink" title="min()"></a><strong>min()</strong></h1><p>最后但并非最不重要的一点是，我们有 min()，它需要两个值并使用该 CSS 属性的最小值。这与 max() 正好相反。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- html ---</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">--- css ---</span><br><span class="line">.box &#123;</span><br><span class="line">width: min(50%, 500px);</span><br><span class="line">height: min(60%, 300px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这个输出将与我们的 max() 完全相反。它将其宽度和高度设置为最小值。</p>]]></content>
      
      
      <categories>
          
          <category> 每天学点小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么Proxy一定要配合Reflect使用</title>
      <link href="/blog/2022/05/02/01692a6/"/>
      <url>/blog/2022/05/02/01692a6/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>EcmaScript 2015 中引入了 <strong>Proxy 代理</strong> 与 <strong>Reflect 反射</strong> 两个新的内置模块。</p><p>我们可以利用 Proxy 和 Reflect 来实现对于对象的代理劫持操作，类似于 Es 5 中 **Object.defineProperty()**的效果，不过 Reflect &amp; Proxy 远远比它强大。</p><p>大多数开发者都了解这两个 Es6 中的新增内置模块，可是你也许并不清楚为什么 Proxy 一定要配合 Reflect 使用。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li><strong>Proxy</strong> 代理，它内置了一系列”陷阱“用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</li><li><strong>Reflect</strong> 反射，它提供拦截 JavaScript 操作的方法。这些方法与 <strong>Proxy</strong> 的方法相同。</li></ul><p><strong>简单来说，我们可以通过 Proxy 创建对于原始对象的代理对象，从而在代理对象中使用 Reflect 达到对于 JavaScript 原始操作的拦截。</strong></p><p>如果你还不了解 &amp; ，那么赶快去 MDN 上去补习他们的知识吧。</p><p>毕竟大名鼎鼎的 VueJs/Core 中核心的响应式模块就是基于这两个 Api 来实现的。</p><h1 id="单独使用-Proxy"><a href="#单独使用-Proxy" class="headerlink" title="单独使用 Proxy"></a>单独使用 Proxy</h1><p>开始的第一个例子，我们先单独使用 Proxy 来烹饪一道简单的开胃小菜：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;wang.haoyu&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// get陷阱中target表示原对象 key表示访问的属性名</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;劫持你的数据访问&#x27;</span> + key);</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name <span class="comment">// 劫持你的数据访问name -&gt; wang.haoyu</span></span><br></pre></td></tr></table></figure><p>看起来很简单对吧，我们通过 Proxy 创建了一个基于 obj 对象的代理，同时在 Proxy 中声明了一个 get 陷阱。</p><p>当访问我们访问 proxy.name 时实际触发了对应的 get 陷阱，它会执行 get 陷阱中的逻辑，同时会执行对应陷阱中的逻辑，最终返回对应的 <code>target[key]</code> 也就是所谓的 <code>wang.haoyu</code> 。</p><h1 id="Proxy-中的-receiver"><a href="#Proxy-中的-receiver" class="headerlink" title="Proxy 中的 receiver"></a>Proxy 中的 receiver</h1><p>上边的 Demo 中一切都看起来顺风顺水没错吧，细心的同学在阅读 Proxy 的 MDN 文档上可能会发现其实 Proxy 中 get 陷阱中还会存在一个额外的参数 receiver 。</p><p>那么这里的 receiver 究竟表示什么意思呢？<strong>大多数同学会将它理解成为代理对象，但这是不全面的。</strong></p><p>接下来同样让我们以一个简单的例子来作为切入点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;wang.haoyu&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// get陷阱中target表示原对象 key表示访问的属性名</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(receiver === proxy);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// log: true</span></span><br><span class="line">proxy.name;</span><br></pre></td></tr></table></figure><p>上述的例子中，我们在 Proxy 实例对象的 get 陷阱上接收了 receiver 这个参数。</p><p>同时，我们在陷阱内部打印 <code>console.log(receiver === proxy);</code> 它会打印出 true ，表示这里 receiver 的确是和代理对象相等的。</p><p><strong>所以 receiver 的确是可以表示代理对象，但是这仅仅是 receiver 代表的一种情况而已。</strong></p><p>接下来我们来看另外一个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;19Qingfeng&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(parent, &#123;</span><br><span class="line">  <span class="comment">// get陷阱中target表示原对象 key表示访问的属性名</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(receiver === proxy);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;wang.haoyu&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置obj继承与parent的代理对象proxy</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// log: false</span></span><br><span class="line">obj.value</span><br></pre></td></tr></table></figure><p>我们可以看到，上述的代码同样我在 proxy 对象的 get 陷阱上打印了 <code>console.log(receiver === proxy);</code> 结果却是 false 。</p><p>那么你可以稍微思考下这里的 receiver 究竟是什么呢？其实这也是 proxy 中 get 陷阱第三个 receiver 存在的意义。</p><p><strong>它是为了传递正确的调用者指向</strong>，你可以看看下方的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(parent, &#123;</span><br><span class="line">  <span class="comment">// get陷阱中target表示原对象 key表示访问的属性名</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">-   <span class="built_in">console</span>.log(receiver === proxy) <span class="comment">// log:false</span></span><br><span class="line">+   <span class="built_in">console</span>.log(receiver === obj) <span class="comment">// log:true</span></span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>其实简单来说，get 陷阱中的 receiver 存在的意义就是为了正确的在陷阱中传递上下文。</strong></p><p>涉及到属性访问时，不要忘记 get 陷阱还会触发对应的属性访问器，也就是所谓的 get 访问器方法。</p><p>我们可以清楚的看到上述的 receiver 代表的是继承与 Proxy 的对象，也就是 obj。</p><p><strong>看到这里，我们明白了 Proxy 中 get 陷阱的 receiver 不仅仅代表的是 Proxy 代理对象本身，同时也许他会代表继承 Proxy 的那个对象。</strong></p><p>其实本质上来说它还是为了确保陷阱函数中调用者的正确的上下文访问，比如这里的 receiver 指向的是 obj 。</p><div class="note info modern"><p>当然，你不要将 revceiver 和 get 陷阱中的 this 弄混了，陷阱中的 this 关键字表示的是代理的 handler 对象。</p></div><p>比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;19Qingfeng&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === handler); <span class="comment">// log: true</span></span><br><span class="line">    <span class="built_in">console</span>.log(receiver === obj); <span class="comment">// log: true</span></span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(parent, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;wang.haoyu&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置obj继承与parent的代理对象proxy</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// log: false</span></span><br><span class="line">obj.value</span><br></pre></td></tr></table></figure><h1 id="Reflect-中的-receiver"><a href="#Reflect-中的-receiver" class="headerlink" title="Reflect 中的 receiver"></a>Reflect 中的 receiver</h1><p>在清楚了 Proxy 中 get 陷阱的 receiver 后，趁热打铁我们来聊聊 Reflect 反射 API 中 get 陷阱的 receiver。</p><p>我们知道在 Proxy 中（以下我们都以 get 陷阱为例）第三个参数 receiver 代表的是代理对象本身或者继承与代理对象的对象，它表示触发陷阱时正确的上下文。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;19Qingfeng&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    <span class="comment">// 这里相当于 return target[key]</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(parent, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;wang.haoyu&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置obj继承与parent的代理对象proxy</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// log: false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.value);</span><br></pre></td></tr></table></figure><p>我们稍微分析下上边的代码：</p><ul><li>当我们调用 obj.value 时，由于 obj 本身不存在 value 属性。</li><li>它继承的 proxy 对象中存在 value 的属性访问操作符，所以会发生屏蔽效果。</li><li>此时会触发 proxy 上的 get value() 属性访问操作。</li><li>同时由于访问了 proxy 上的 value 属性访问器，所以此时会触发 get 陷阱。</li><li>进入陷阱时，target 为源对象也就是 parent ，key 为 value 。</li><li>陷阱中返回 <code>Reflect.get(target,key)</code> 相当于 <code>target[key]</code>。</li><li>此时，不知不觉中 this 指向在 get 陷阱中被偷偷修改掉了！！</li><li>原本调用方的 obj 在陷阱中被修改成为了对应的 target 也就是 parent 。</li><li>自然而然打印出了对应的 <code>parent[value]</code> 也就是 19Qingfeng 。</li></ul><p>这显然不是我们期望的结果，当我访问 obj.value 时，我希望应该正确输出对应的自身上的 name 属性也就是所谓的 obj.value =&gt; wang.haoyu 。</p><p>那么，Relfect 中 get 陷阱的 receiver 就大显神通了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;19Qingfeng&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">-   <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">+   <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(parent, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;wang.haoyu&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置obj继承与parent的代理对象proxy</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// log: wang.haoyu</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.value);</span><br></pre></td></tr></table></figure><p>上述代码原理其实非常简单：</p><ul><li>首先，之前我们提到过在 Proxy 中 get 陷阱的 receiver 不仅仅会表示代理对象本身同时也还有可能表示继承于代理对象的对象，具体需要区别与调用方。这里显然它是指向继承与代理对象的 obj 。</li><li>其次，我们在 Reflect 中 get 陷阱中第三个参数传递了 Proxy 中的 receiver 也就是 obj 作为形参，它会修改调用时的 this 指向。</li></ul><div class="note info modern"><p>你可以简单的将 <code>Reflect.get(target, key, receiver)</code> 理解成为 <code>target[key].call(receiver)</code>，不过这是一段伪代码，但是这样你可能更好理解。</p></div><p>相信看到这里你已经明白 Relfect 中的 receiver 代表的含义是什么了，没错它正是可以修改属性访问中的 this 指向为传入的 receiver 对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信看到这里大家都已经明白了，为什么Proxy一定要配合Reflect使用。恰恰是为什么触发代理对象的劫持时保证正确的 this 上下文指向。</p><p>我们再来稍稍回忆一下，针对于 get 陷阱（当然 set 其他之类涉及到 receiver 的陷阱同理）：</p><ul><li>Proxy 中接受的 Receiver 形参表示代理对象本身或者继承与代理对象的对象。</li><li>Reflect 中传递的 Receiver 实参表示修改执行原始操作时的 this 指向。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现一个深拷贝</title>
      <link href="/blog/2022/05/02/0789bf6/"/>
      <url>/blog/2022/05/02/0789bf6/</url>
      
        <content type="html"><![CDATA[<p>其实深拷贝可以拆分成 2 步，浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象就进行递归操作，两个一结合就实现了深拷贝。</p><h1 id="第一步：简单实现"><a href="#第一步：简单实现" class="headerlink" title="第一步：简单实现"></a>第一步：简单实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneShallow</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    <span class="attr">book</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a1</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">a2</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">a3</span>: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = cloneShallow(a);</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;高级前端进阶&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don&#x27;t Know JS&#x27;, price: &#x27;55&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: null,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码是浅拷贝实现，只要稍微改动下，加上是否是对象的判断并在相应的位置使用递归就可以实现简单深拷贝。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep1</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                target[key] = cloneDeep1(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面测试用例测试一下</span></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep1(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;, </span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: &#123;&#125;,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>一个简单的深拷贝就完成了，但是这个实现还存在很多问题。</p><ul><li>1、没有对传入参数进行校验，传入 <code>null</code> 时应该返回 <code>null</code> 而不是 <code>&#123;&#125;</code></li><li>2、对于对象的判断逻辑不严谨，因为 <code>typeof null === &#39;object&#39;</code></li><li>3、没有考虑数组的兼容</li></ul><h1 id="第二步：拷贝数组"><a href="#第二步：拷贝数组" class="headerlink" title="第二步：拷贝数组"></a>第二步：拷贝数组</h1><p>对于对象的判断，判断方案如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是用在这里并不合适，因为我们要保留数组这种情况，所以这里使用 <code>typeof</code> 来处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">//&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">//&quot;array&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//&quot;function&quot; (特殊情况)</span></span><br></pre></td></tr></table></figure><p>改动过后的 isObject 判断逻辑如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以兼容数组的写法如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep2</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; <span class="comment">// 非对象返回自身</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep2(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面测试用例测试一下</span></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep2(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: null,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h1 id="第三步：循环引用"><a href="#第三步：循环引用" class="headerlink" title="第三步：循环引用"></a>第三步：循环引用</h1><p>我们知道 <code>JSON</code> 无法深拷贝循环引用，遇到这种情况会抛出异常。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处 a 是文章开始的测试用例</span></span><br><span class="line">a.circleRef = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="comment">// TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure><h2 id="1、使用哈希表"><a href="#1、使用哈希表" class="headerlink" title="1、使用哈希表"></a>1、使用哈希表</h2><p>解决方案很简单，其实就是循环检测，我们设置一个数组或者哈希表存储已拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出该值并返回即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); <span class="comment">// 新增代码，查哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    hash.set(source, target); <span class="comment">// 新增代码，哈希表设值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep3(source[key], hash); <span class="comment">// 新增代码，传入哈希表</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，看看效果如何。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处 a 是文章开始的测试用例</span></span><br><span class="line">a.circleRef = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep3(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">//     a1: undefined,</span></span><br><span class="line"><span class="comment">//    a2: null,</span></span><br><span class="line"><span class="comment">//     a3: 123,</span></span><br><span class="line"><span class="comment">//     book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;,</span></span><br><span class="line"><span class="comment">//     circleRef: &#123;name: &quot;muyiy&quot;, book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>完美！</p><h2 id="2、使用数组"><a href="#2、使用数组" class="headerlink" title="2、使用数组"></a>2、使用数组</h2><p>这里使用了<code>ES6</code> 中的 <code>WeakMap</code> 来处理，那在 <code>ES5</code> 下应该如何处理呢？</p><p>也很简单，使用数组来处理就好啦，代码如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, uniqueList</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (!uniqueList) uniqueList = []; <span class="comment">// 新增代码，初始化数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============= 新增代码</span></span><br><span class="line">    <span class="comment">// 数据已经存在，返回保存的数据</span></span><br><span class="line">    <span class="keyword">var</span> uniqueData = find(uniqueList, source);</span><br><span class="line">    <span class="keyword">if</span> (uniqueData) &#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueData.target;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据不存在，保存源数据，以及对应的引用</span></span><br><span class="line">    uniqueList.push(&#123;</span><br><span class="line">        <span class="attr">source</span>: source,</span><br><span class="line">        <span class="attr">target</span>: target</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep3(source[key], uniqueList); <span class="comment">// 新增代码，传入数组</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增方法，用于查找</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i].source === item) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用上面测试用例已测试通过</span></span><br></pre></td></tr></table></figure><p>现在已经很完美的解决了循环引用这种情况，那其实还是一种情况是引用丢失，我们看下面的例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">a</span>: obj1, <span class="attr">b</span>: obj1&#125;;</span><br><span class="line"></span><br><span class="line">obj2.a === obj2.b; </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = cloneDeep2(obj2);</span><br><span class="line">obj3.a === obj3.b; </span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>引用丢失在某些情况下是有问题的，比如上面的对象 obj2，obj2 的键值 a 和 b 同时引用了同一个对象 obj1，使用 cloneDeep2 进行深拷贝后就丢失了引用关系变成了两个不同的对象，那如何处理呢。</p><p>其实你有没有发现，我们的 cloneDeep3 已经解决了这个问题，因为只要存储已拷贝过的对象就可以了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj3 = cloneDeep3(obj2);</span><br><span class="line">obj3.a === obj3.b; </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>完美！</p><h1 id="第四步：拷贝-Symbol"><a href="#第四步：拷贝-Symbol" class="headerlink" title="第四步：拷贝 Symbol"></a>第四步：拷贝 Symbol</h1><p>这个时候可能要搞事情了，那我们能不能拷贝 Symol 类型呢？</p><p>当然可以，不过 <code>Symbol</code> 在 <code>ES6</code> 下才有，我们需要一些方法来检测出 <code>Symble</code> 类型。</p><p>方法一：<code>Object.getOwnPropertySymbols(...)</code></p><p>方法二：<code>Reflect.ownKeys(...)</code></p><p><strong>对于方法一</strong>可以查找一个给定对象的符号属性时返回一个 <code>?symbol</code> 类型的数组。注意，每个初始化的对象都是没有自己的 <code>symbol</code> 属性的，因此这个数组可能为空，除非你已经在对象上设置了 <code>symbol</code> 属性。（来自MDN）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 创建新的symbol类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">&quot;b&quot;</span>); <span class="comment">// 从全局的symbol注册?表设置和取得symbol</span></span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&quot;localSymbol&quot;</span>;</span><br><span class="line">obj[b] = <span class="string">&quot;globalSymbol&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols)         <span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols[<span class="number">0</span>])      <span class="comment">// Symbol(a)</span></span><br></pre></td></tr></table></figure><p><strong>对于方法二</strong>返回一个由目标对象<strong>自身</strong>的属性键组成的数组。它的返回值等同于<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>。(来自MDN)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;); <span class="comment">// [ &quot;z&quot;, &quot;y&quot;, &quot;x&quot; ]</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys([]); <span class="comment">// [&quot;length&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>.for(<span class="string">&quot;comet&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;meteor&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;[sym]: <span class="number">0</span>, <span class="string">&quot;str&quot;</span>: <span class="number">0</span>, <span class="string">&quot;773&quot;</span>: <span class="number">0</span>, <span class="string">&quot;0&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           [sym2]: <span class="number">0</span>, <span class="string">&quot;-1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;8&quot;</span>: <span class="number">0</span>, <span class="string">&quot;second str&quot;</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj);</span><br><span class="line"><span class="comment">// [ &quot;0&quot;, &quot;8&quot;, &quot;773&quot;, &quot;str&quot;, &quot;-1&quot;, &quot;second str&quot;, Symbol(comet), Symbol(meteor) ]</span></span><br><span class="line"><span class="comment">// 注意顺序</span></span><br><span class="line"><span class="comment">// Indexes in numeric order, </span></span><br><span class="line"><span class="comment">// strings in insertion order, </span></span><br><span class="line"><span class="comment">// symbols in insertion order</span></span><br></pre></td></tr></table></figure><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>思路就是先查找有没有 <code>Symbol</code> 属性，如果查找到则先遍历处理 <code>Symbol</code> 情况，然后再处理正常情况，多出来的逻辑就是下面的新增代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep4</span>(<span class="params">source, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    hash.set(source, target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============= 新增代码</span></span><br><span class="line">    <span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(source); <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">if</span> (symKeys.length) &#123; <span class="comment">// 查找成功    </span></span><br><span class="line">        symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[symKey])) &#123;</span><br><span class="line">                target[symKey] = cloneDeep4(source[symKey], hash); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[symKey] = source[symKey];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep4(source[key], hash); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试下效果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处 a 是文章开始的测试用例</span></span><br><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 创建新的symbol类型</span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;b&quot;</span>); <span class="comment">// 从全局的symbol注册?表设置和取得symbol</span></span><br><span class="line"></span><br><span class="line">a[sym1] = <span class="string">&quot;localSymbol&quot;</span>;</span><br><span class="line">a[sym2] = <span class="string">&quot;globalSymbol&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep4(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">//     a1: undefined,</span></span><br><span class="line"><span class="comment">//    a2: null,</span></span><br><span class="line"><span class="comment">//     a3: 123,</span></span><br><span class="line"><span class="comment">//     book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;,</span></span><br><span class="line"><span class="comment">//     circleRef: &#123;name: &quot;muyiy&quot;, book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;,</span></span><br><span class="line"><span class="comment">//  [Symbol(a)]: &#x27;localSymbol&#x27;,</span></span><br><span class="line"><span class="comment">//  [Symbol(b)]: &#x27;globalSymbol&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>完美！</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep4</span>(<span class="params">source, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(source) ? [...source] : &#123; ...source &#125;; <span class="comment">// 改动 1</span></span><br><span class="line">    hash.set(source, target);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Reflect</span>.ownKeys(target).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123; <span class="comment">// 改动 2</span></span><br><span class="line">        <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">            target[key] = cloneDeep4(source[key], hash); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试已通过</span></span><br></pre></td></tr></table></figure><p>这里说一下改动 1，因为使用 <code>Reflect.ownKeys()</code> 获取所有的键值，所以 target 需要改成如上所示，返回一个新数组或者新对象，获取到源对象之后就可以如改动 2 所示遍历赋值即可。</p><p>这种方式的问题在于不能深拷贝原型链上的数据，因为 <code>Reflect.ownKeys()</code> 返回的是目标对象<strong>自身</strong>的属性键组成的数组。如果想深拷贝原型链上的数据怎么办，那用 <code>for..in</code> 就可以了。</p><p>完美！</p><h2 id="延伸知识"><a href="#延伸知识" class="headerlink" title="延伸知识"></a>延伸知识</h2><p>我们延伸下介绍以下两个知识点，分别是<strong>构造字面量数组时使用展开语法</strong>和<strong>构造字面量对象时使用展开语法</strong>。（以下代码示例来源于 MDN）</p><h3 id="1、展开语法之字面量数组"><a href="#1、展开语法之字面量数组" class="headerlink" title="1、展开语法之字面量数组"></a>1、展开语法之字面量数组</h3><p>这是 <code>ES2015 （ES6）</code> 才有的语法，可以通过字面量方式, 构造新数组，而不再需要组合使用  <code>push</code>, <code>splice</code>, <code>concat</code> 等方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parts = [<span class="string">&#x27;shoulders&#x27;</span>, <span class="string">&#x27;knees&#x27;</span>]; </span><br><span class="line"><span class="keyword">var</span> lyrics = [<span class="string">&#x27;head&#x27;</span>, ...parts, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;toes&#x27;</span>]; </span><br><span class="line"><span class="comment">// [&quot;head&quot;, &quot;shoulders&quot;, &quot;knees&quot;, &quot;and&quot;, &quot;toes&quot;]</span></span><br></pre></td></tr></table></figure><p>这里的使用方法和参数列表的展开有点类似。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">v, w, x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">myFunction(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>返回的是新数组，对新数组修改之后不会影响到旧数组，类似于 <code>arr.slice()</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// like arr.slice()</span></span><br><span class="line">arr2.push(<span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2 此时变成 [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arr 不受影响</span></span><br></pre></td></tr></table></figure><p>展开语法和 <code>Object.assign()</code> 行为一致, 执行的都是浅拷贝（即只遍历一层）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]];</span><br><span class="line"><span class="keyword">var</span> b = [...a];</span><br><span class="line">b.shift().shift(); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [[], [2], [3]]</span></span><br></pre></td></tr></table></figure><p>这里 a 是多层数组，b 只拷贝了第一层，对于第二层依旧和 a 持有同一个地址，所以对 b 的修改会影响到 a。</p><h3 id="2、展开语法之字面量对象"><a href="#2、展开语法之字面量对象" class="headerlink" title="2、展开语法之字面量对象"></a>2、展开语法之字面量对象</h3><p>这是 <code>ES2018</code> 才有的语法，将已有对象的所有<strong>可枚举属性</strong>拷贝到新构造的对象中，类似于  <code>Object.assign()</code> 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code> 函数会触发 setters，而展开语法不会。有时候不能替换或者模拟 <code>Object.assign()</code> 函数，因为会得到意想不到的结果，如下所示。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params"> ...objects </span>) =&gt;</span> ( &#123; ...objects &#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = merge ( obj1, obj2);</span><br><span class="line"><span class="comment">// &#123; 0: &#123; foo: &#x27;bar&#x27;, x: 42 &#125;, 1: &#123; foo: &#x27;baz&#x27;, y: 13 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = merge ( &#123;&#125;, obj1, obj2);</span><br><span class="line"><span class="comment">// &#123; 0: &#123;&#125;, 1: &#123; foo: &#x27;bar&#x27;, x: 42 &#125;, 2: &#123; foo: &#x27;baz&#x27;, y: 13 &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>这里实际上是将多个解构变为剩余参数（ <code>rest</code> ），然后再将剩余参数展开为字面量对象.</p><h2 id="第五步：破解递归爆栈"><a href="#第五步：破解递归爆栈" class="headerlink" title="第五步：破解递归爆栈"></a>第五步：破解递归爆栈</h2><p>上面四步使用的都是递归方法，但是有一个问题在于会爆栈，错误提示如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure><p>那应该如何解决呢？其实我们使用循环就可以了，代码如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep5</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">parent</span>: root,</span><br><span class="line">            <span class="attr">key</span>: <span class="literal">undefined</span>,</span><br><span class="line">            <span class="attr">data</span>: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        <span class="comment">// 深度优先</span></span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        <span class="attr">parent</span>: res,</span><br><span class="line">                        <span class="attr">key</span>: k,</span><br><span class="line">                        <span class="attr">data</span>: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数防抖和节流</title>
      <link href="/blog/2022/04/26/22-04-26/"/>
      <url>/blog/2022/04/26/22-04-26/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 <code>resize</code>、<code>scroll</code>、<code>mousemove </code>等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p><p>通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。</p><p>让我们先来看看在事件持续触发的过程中频繁执行函数是怎样的一种情况。</p><p><code>html </code>文件中代码如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> num = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        content.innerHTML = num++;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    content.onmousemove = count;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，div 元素绑定了 <code>mousemove </code>事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下</p><p><img src="https://alanni-1.github.io/blog/img/22-04-26/01.webp"></p><p>可以看到，在没有通过其它操作的情况下，函数被频繁地执行导致页面上数据变化特别快。所以，接下来让我们来看看防抖和节流是如何去解决这个问题的。</p><h1 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（<code>debounce</code>）</h1><p><strong>所谓防抖，就是指触发事件后如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</strong></p><p>防抖函数分为非立即执行版和立即执行版。</p><h2 id="非立即执行版"><a href="#非立即执行版" class="headerlink" title="非立即执行版"></a>非立即执行版</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        </span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info simple"><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p></div><p>我们依旧使用上述绑定 <code>mousemove </code>事件的例子，通过上面的防抖函数，我们可以这么使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">content.onmousemove = debounce(count,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://alanni-1.github.io/blog/img/22-04-26/02.webp"></p><p>可以看到，在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1 秒内又触发了事件，则会重新计算函数执行时间。</p><p>上述防抖函数的代码还需要注意的是 this 和 参数的传递</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br></pre></td></tr></table></figure><p>防抖函数的代码使用这两行代码来获取 this 和 参数，是为了让 <code>debounce </code>函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。</p><h2 id="立即执行版"><a href="#立即执行版" class="headerlink" title="立即执行版"></a>立即执行版</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info simple"><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p></div><p>使用方法同上，效果如下</p><p><img src="https://alanni-1.github.io/blog/img/22-04-26/03.webp"></p><p>在开发过程中，我们需要根据不同的场景来决定我们需要使用哪一个版本的防抖函数，一般来讲上述的防抖函数都能满足大部分的场景需求。但我们也可以将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版的防抖函数。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate true 表立即执行，false 表非立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait,immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h1><p><strong>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。</strong></p><p>对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。</p><h2 id="立即执行版-1"><a href="#立即执行版-1" class="headerlink" title="立即执行版"></a>立即执行版</h2><p><strong>立即执行版又称时间戳版，触发事件后会立即执行回调，在规定的时间内不会再次触发。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">content.onmousemove = throttle(count,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://alanni-1.github.io/blog/img/22-04-26/04.webp"></p><p>可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。</p><h2 id="非立即执行版-1"><a href="#非立即执行版-1" class="headerlink" title="非立即执行版"></a>非立即执行版</h2><p><strong>非立即执行版又称定时器版，触发事件后n秒后才会触发事件回调，并且在此期间不会再次触发事件。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式同上，效果如下</p><p><img src="https://alanni-1.github.io/blog/img/22-04-26/05.webp"></p><p>可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p><div class="note info simple"><p>我们应该可以很容易的发现，其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p></div><h2 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a>合并</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数节流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>type 1 表时间戳版，2 表定时器版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait ,type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type===<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(type===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                previous = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type===<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    timeout = <span class="literal">null</span>;</span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="防抖和节流的区别"><a href="#防抖和节流的区别" class="headerlink" title="防抖和节流的区别"></a>防抖和节流的区别</h2><div class="note info no-icon flat"><p>防抖：<br>触发事件后在规定时间内又触发了事件，则会重新计算函数执行时间。</p><p>节流：<br>触发事件后在规定时间内无法在触发事件，等规定时间结束才能再次触发。</p></div><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><div class="note info no-icon flat"><p>防抖：<br>用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源。</p><p>节流：<br>监听页面滚动的时候，规定多少秒内只能发送一次ajax请求，稀释请求的执行频率。</p></div><h2 id="防抖与节流的两种不同版本区别"><a href="#防抖与节流的两种不同版本区别" class="headerlink" title="防抖与节流的两种不同版本区别"></a>防抖与节流的两种不同版本区别</h2><div class="note info no-icon flat"><p>防抖：<br>非立即执行版本，会再用户停止触发事件n秒后执行指定回调；立即执行版本，会在用户一触发事件就执行回调，在停止触发事件n秒后才能再次触发事件回调。</p><p>节流：<br>立即执行版本，触发事件后会立即执行回调，在规定的时间内不会再次触发；非立即执行版本，触发事件后n秒后才会触发事件回调，并且在此期间不会再次触发事件。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 实现文本的单行和多行溢出省略效果</title>
      <link href="/blog/2021/07/28/fiw/"/>
      <url>/blog/2021/07/28/fiw/</url>
      
        <content type="html"><![CDATA[<h1 id="当行文本"><a href="#当行文本" class="headerlink" title="当行文本"></a>当行文本</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; </span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis; </span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>overflow: hidden</code>（文字长度超出限定宽度，则隐藏超出的内容）</li><li><code>white-space: nowrap</code>（设置文字在一行显示，不能换行）</li><li><code>text-overflow: ellipsis</code>（规定当文本溢出时，显示省略符号来代表被修剪的文本）</li></ul><h1 id="多行文本（css）"><a href="#多行文本（css）" class="headerlink" title="多行文本（css）"></a>多行文本（css）</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">   -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>-webkit-line-clamp: 2</code>（用来限制在一个块元素显示的文本的行数, 2 表示最多显示 2 行。为了实现该效果，它需要组合其他的WebKit属性）</li><li><code>display: -webkit-box</code>（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）</li><li><code>-webkit-box-orient: vertical</code>（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）</li><li><code>overflow: hidden</code>（文本溢出限定的宽度就隐藏内容）</li><li><code>text-overflow: ellipsis</code>（多行文本的情况下，用省略号“…”隐藏溢出范围的文本)</li></ul><h1 id="多行文本（js）"><a href="#多行文本（js）" class="headerlink" title="多行文本（js）"></a>多行文本（js）</h1><ul><li>监听DOM尺寸变化</li><li>判断是否溢出 scrollHeight &gt; offsetHeight</li><li>二分查找多行截取字符临界值（算法的解法：判断字符串是否溢出，二分查找字符串溢出临界子串，控制…显示）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 如何实现多行文本展开收起效果</title>
      <link href="/blog/2021/07/28/forw/"/>
      <url>/blog/2021/07/28/forw/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img src="https://alanni-1.github.io/blog/img/forw/01.png"></p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="https://alanni-1.github.io/blog/img/forw/02.gif"></p><hr><p>主要难点：</p><ul><li>如何实现 <code>展开</code> 和 <code>收起</code> 切换按钮的文字环绕效果</li><li>如何实现<code>多行文本溢出省略</code>效果</li><li>如何实现 <code>展开</code> 和 <code>收起</code> 的状态or文字切换</li></ul><p>初始html：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>展开<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    但听得蹄声如雷，十余乘马疾风般卷上山来。马上乘客一色都是玄色薄毡大氅，</span><br><span class="line">    里面玄色布衣，但见人似虎，马如龙，人既矫捷，马亦雄骏，每一匹马都是高头</span><br><span class="line">    长腿，通体黑毛，奔到近处，群雄眼前一亮，金光闪闪，却见每匹马的蹄铁竟然</span><br><span class="line">    是黄金打就。来者一共是一十九骑，人数虽不甚多，气势之壮，却似有如千军万</span><br><span class="line">    马一般，前面一十八骑奔到近处，拉马向两旁一分，最后一骑从中驰出<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.text</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">475px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: aqua solid <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: dodgerblue;</span></span><br><span class="line"><span class="css">    <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/forw/03.png"></p><h1 id="一、控制按钮文字环绕效果"><a href="#一、控制按钮文字环绕效果" class="headerlink" title="一、控制按钮文字环绕效果"></a>一、控制按钮文字环绕效果</h1><p>一般展开、收起按钮都在文字的右下脚：</p><ul><li>居右：<code>float: right</code></li><li>居下：<code>margin-top</code></li></ul><p>但 <code>margin</code> 虽然可以将按钮局下，但它无法实现文字环绕效果，所以我们这里利用伪元素实现：</p><ul><li>居右：<code>float: right</code></li><li>居下：<code>.text::before</code></li></ul><div class="note info no-icon flat"><p>居右</p></div><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/forw/04.png"></p><div class="note info no-icon flat"><p>居左</p></div><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现出现了高度塌陷（ <code>calc(100% - 20px)</code> 无效）的问题：</p><div class="note warning no-icon flat"><p>由于包含块的高度没有显式指定，并且该元素不是绝对定位，则计算值伪 auto，auto * 100/100 = NaN</p><p>— CSS 世界</p></div><p>此时解决办法有：</p><ul><li>设置显式的高度值：这里高度是动态的，没办法显式指定，所以此方法不可用❌</li><li>如果包含块的高度显式指定，则设置该元素为绝对定位：包含块的高度是动态的，没办法显式指定，所以此方法也不可用❌</li><li>在元素外边包一层具有包裹性又具有定位特性的标签：✅</li></ul><p>这里包一层 flex 布局。因为在 flex 布局的子项中，可以通过百分比来计算变化高度，因此，这里需要给  <code>.text</code> 包裹一层，然后设置 <code>display: flex</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;exp&quot;</span>&gt;</span>展开<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">     但听得蹄声如雷，十余乘马疾风般卷上山来。马上乘客一色都是玄色薄毡大氅，</span><br><span class="line">     里面玄色布衣，但见人似虎，马如龙，人既矫捷，马亦雄骏，每一匹马都是高头</span><br><span class="line">     长腿，通体黑毛，奔到近处，群雄眼前一亮，金光闪闪，却见每匹马的蹄铁竟然</span><br><span class="line">     是黄金打就。来者一共是一十九骑，人数虽不甚多，气势之壮，却似有如千军万</span><br><span class="line">     马一般，前面一十八骑奔到近处，拉马向两旁一分，最后一骑从中驰出<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"> <span class="selector-class">.content</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.text</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">   <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">   <span class="attribute">float</span>: right;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: -<span class="number">20px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.btn</span> &#123;</span><br><span class="line">   <span class="attribute">float</span>: right;</span><br><span class="line">   <span class="attribute">clear</span>: both;</span><br><span class="line">   <span class="attribute">margin-right</span>: <span class="number">8px</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/forw/05.png"></p><h1 id="二、多行文本溢出省略效果"><a href="#二、多行文本溢出省略效果" class="headerlink" title="二、多行文本溢出省略效果"></a>二、多行文本溢出省略效果</h1><p>我们在 <a href="https://alanni-1.github.io/blog/2021/07/28/fiw/">CSS 实现文本的单行和多行溢出省略效果</a> 介绍过：</p><p><strong>多行文本（css）</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  -webkit-line-clamp: <span class="number">3</span>;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>-webkit-line-clamp: 3</code>（用来限制在一个块元素显示的文本的行数, 2 表示最多显示 2 行。为了实现该效果，它需要组合其他的WebKit属性）</li><li><code>display: -webkit-box</code>（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）</li><li><code>-webkit-box-orient: vertical</code>（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）</li><li><code>overflow: hidden</code>（文本溢出限定的宽度就隐藏内容）</li><li><code>text-overflow: ellipsis</code>（多行文本的情况下，用省略号“…”隐藏溢出范围的文本)</li></ul><p><img src="https://alanni-1.github.io/blog/img/forw/06.png"></p><h1 id="三、如何实现-展开-和-收起-的状态切换"><a href="#三、如何实现-展开-和-收起-的状态切换" class="headerlink" title="三、如何实现 展开 和 收起 的状态切换"></a>三、如何实现 <code>展开</code> 和 <code>收起</code> 的状态切换</h1><p>使用 <code>input type=&quot;checkbox&quot;</code> 控制展开与收起效果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;exp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#exp</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">visibility</span>: hidden;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#exp</span><span class="selector-pseudo">:checked</span>+<span class="selector-class">.text</span>&#123;</span></span><br><span class="line"><span class="css">    -webkit-line-clamp: <span class="number">999</span>; <span class="comment">/*设置一个足够大的行数就可以了*/</span></span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://alanni-1.github.io/blog/img/forw/07.png"></p><p>但文字展开后控制按钮依然显示 <code>展开</code> ，应该显示 <code>收起</code> 才对</p><p>这里使用伪类生成技术，具体做法就是去除或者隐藏按钮里面的文字，采用伪元素生成</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;exp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.btn</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&#x27;展开&#x27;</span></span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#exp</span><span class="selector-pseudo">:checked</span>+<span class="selector-class">.text</span> <span class="selector-class">.btn</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&#x27;收起&#x27;</span></span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终，大功告成：</p><p><img src="https://alanni-1.github.io/blog/img/forw/02.gif"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 margin 塌陷和 margin 合并及其解决方案</title>
      <link href="/blog/2021/07/17/three/"/>
      <url>/blog/2021/07/17/three/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>小问题总是被人们视而不见，等到遇到的时候又突然想不起来，无从下手，所以我们需要经常总结，这样可以帮助我们更好的记忆东西。今天我们总结两个不起眼的小问题：<code>margin</code> 塌陷和 <code>margin</code> 合并。</p><h1 id="margin-塌陷"><a href="#margin-塌陷" class="headerlink" title="margin 塌陷"></a>margin 塌陷</h1><h2 id="什么是-margin-塌陷"><a href="#什么是-margin-塌陷" class="headerlink" title="什么是 margin 塌陷"></a>什么是 margin 塌陷</h2><p>我们先来举个例子，然后引出什么是 <code>margin</code> 塌陷</p><p>需求：在父元素中，通过 <code>margin</code> 让父元素相对左边及顶部距离<code>100px</code>，也让子元素相对于父元素左边和顶部各<code>50px</code>。</p><p><strong>代码如下：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">219</span>, <span class="number">68</span>, <span class="number">101</span>);</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.father</span> <span class="selector-tag">div</span><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">56</span>, <span class="number">248</span>, <span class="number">207</span>);</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码看上去没有什么问题，看下效果</strong></p><p><img src="https://alanni-1.github.io/blog/img/three/01.png"></p><p>惊奇的发现，结果出乎我们意料！水平方向的距离确实没问题，但是垂直方向上，明明子元素设置了<code>margin-top</code>距离顶部<code>50px</code>，按道理它会距离父元素顶部<code>50px</code>才对。</p><p>这种现象被称之为<code>margin</code>塌陷。但很多人可能都不太理解，为什么叫它塌陷？其实你可以这样理解，如上述例子，原本子元素要距离父元素顶部<code>50px</code>，现在没有了，也就是父元素的顶棚对子元素来说没有作用，相当于没有，相当于塌陷下来了。所以叫margin塌陷。</p><p>一句话总结：父子嵌套的元素垂直方向的<code>margin</code>取最大值。</p><p>但是有的时候我们不希望有这样的问题，那我们如何解决<code>margin</code>塌陷的问题呢？</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="什么是BFC和作用"><a href="#什么是BFC和作用" class="headerlink" title="什么是BFC和作用"></a>什么是BFC和作用</h3><p><code>Block Formatting Context</code>，中文叫块级格式上下文。</p><p><code>CSS</code>将<code>HTML</code>的每一个元素都当成一个盒子，而且它进一步的认为每一个盒子里面都有一套正常的语法规则或者叫渲染规则，它能根据这个规则将写的HTML元素绘制出来，但是我们可以通过一些特定的手段触发<code>BFC</code>，让其所符合的语法规则和原来的语法规则有点不一样。</p><p>也就是触发<code>BFC</code>之后，特定的盒子会遵循另一套语法规则。</p><p><code>BFC</code>听起来挺神奇，能改变一个盒子的语法规则，那到底改变了多少呢，其实也没改变多少。可能千分之一都不到。也就是它只改变了一点点。但是就是这一点点它把解决了<code>margin</code>塌陷和<code>margin</code>合并的问题</p><h3 id="如何触发BFC"><a href="#如何触发BFC" class="headerlink" title="如何触发BFC"></a>如何触发BFC</h3><p>小结触发<code>BFC</code>方法：</p><ol><li><code>float</code>属性为<code>left</code>/<code>right</code></li><li><code>overflow</code>为<code>hidden</code>/<code>scroll</code>/<code>auto</code></li><li><code>position</code>为<code>absolute</code>/<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>/<code>table-cell</code>/<code>table-caption</code></li></ol><p>有些人会想，有这几多方式触发<code>BFC</code>，那用哪种方式好一些？看具体情况，个人认为一个原则：<strong>针对需求，看哪个触发方式没有影响就用那个</strong></p><h2 id="解决margin塌陷的问题"><a href="#解决margin塌陷的问题" class="headerlink" title="解决margin塌陷的问题"></a>解决margin塌陷的问题</h2><p><strong>如下通过<code>overflow: hidden</code>触发<code>bfc</code></strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">219</span>, <span class="number">68</span>, <span class="number">101</span>);</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;<span class="comment">/* 触发bfc */</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.father</span> <span class="selector-tag">div</span><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">56</span>, <span class="number">248</span>, <span class="number">207</span>);</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下</strong></p><p><img src="https://alanni-1.github.io/blog/img/three/02.png"></p><p><strong>问题已经解决！</strong></p><h1 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h1><h2 id="什么是margin合并"><a href="#什么是margin合并" class="headerlink" title="什么是margin合并"></a>什么是margin合并</h2><p>还是来看个例子，把两个兄弟块元素，一个设置下外边距100px，一个设置上外边距100px，让两个元素相距200px。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下</strong></p><p><img src="https://alanni-1.github.io/blog/img/three/03.png"></p><p>我们发现这两个元素之间，他们的<code>margin-bottom</code>和<code>margin-top</code>合并了，并且显示的是较大值。这种现象被称为<code>margin</code>合并。解决的方式也是通过触发<code>bfc</code>来解决</p><h2 id="解决margin合并"><a href="#解决margin合并" class="headerlink" title="解决margin合并"></a>解决margin合并</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">    <span class="comment">/* 触发bfc */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.two</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下</strong></p><p><img src="https://alanni-1.github.io/blog/img/three/04.png"></p><p><strong>解决问题！但是一般不这么解决，为什么？</strong></p><p>因为<code>margin</code>合并和<code>margin</code>塌陷不一样，<code>margin</code>塌陷只添加了<code>CSS</code>，<code>margin</code>合并除了添加<code>CSS</code>，还修改了<code>HTML</code>结构。我们知道一般html结构是不能乱改动的，所以我们通过数学计算来解决这各<code>margin</code>合并的问题。比如上面的例子，我们只要设置前面元素的<code>margin-bottom</code>为<code>200px</code>或者后面元素的<code>margin-top</code>为<code>200px</code>即可，如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.one</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是关于<code>margin</code>塌陷和<code>margin</code>合并的小结，如有问题烦请留言告知</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue/React列表组件中的key作用是什么？</title>
      <link href="/blog/2021/07/16/twe/"/>
      <url>/blog/2021/07/16/twe/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue中的key"><a href="#Vue中的key" class="headerlink" title="Vue中的key"></a>Vue中的key</h2><p>在使用Vue开发项目中，如果使用循环渲染<code>没有使用key</code>的时候，<code>vue会警告</code>。但是这个key的作用是什么。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在Vue官网中提到</p><blockquote><p>建议尽可能在使用 v-for 时提供 kye，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。因为它是Vue识别节点的一个通用机制，key并不与 v-for 特别关联。</p><p>用 key 管理可复用的元素，Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外。</p></blockquote><p>通过上诉可以大致了解 key 可以使 Vue 在复用时快速高效的渲染元素。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Vue在渲染列表的时候采用<code>就地复用</code>的原则,如果改变了dom的顺序，那么vue不会对dom元素的顺序做修改,而是就此复用当前的元素</p><p><strong>假设我们要在BC之间插入一个元素,如图所示</strong></p><p><img src="https://alanni-1.github.io/blog/img/twe/01.png"></p><p><strong>如果我们<code>没有设置key</code>的值那么 Vue 就会把整个列表<code>重新渲染一变</code>，得到如图结果</strong></p><p><img src="https://alanni-1.github.io/blog/img/twe/02.png"></p><p><strong>要是我们<code>添加了key</code>的话 Vue 会通过对先前 key 值配对的属性<code>不会重新渲染</code>一次</strong>，如图（左边没设置key，右边设置了key）</p><p><img src="https://alanni-1.github.io/blog/img/twe/03.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3> <div class="note warning flat"><p>key 值是唯一的，建议不要设置 index 为key值，导致的问题就是以前的数据和重新渲染后的数据随着 key 值的变化从而没法建立关联关系. 这就失去了 key 值存在的意义. 也是导致数据出现诡异的罪魁祸首!</p></div><p>Vue是不直接操作DOM的，是通过js的Object对象来模拟DOM中的节点，比较虚拟DOM是用的diff的算法。在同级A,B,C,D四个节点中，在B和C之间插入E,<strong>没有key的时候</strong>：C更新成了E，D更新成了C，最后插入D，这样效率很低。<br><strong>加上key之后</strong>，就能准确的找到节点的位置：发现ABCD都没变化，直接插入E就可以了。<br>所以<strong>key的作用主要是为了高效的更新虚拟DOM</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list：[</span><br><span class="line">&#123;</span><br><span class="line">id: 1,</span><br><span class="line">name: &#x27;a&#x27;,</span><br><span class="line">//index: 0</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: 2,</span><br><span class="line">name: &#x27;b&#x27;,</span><br><span class="line">//index: 1</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: 3,</span><br><span class="line">name: &#x27;c&#x27;,</span><br><span class="line">//index: 2</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: 4,</span><br><span class="line">name: &#x27;d&#x27;,</span><br><span class="line">//index: 3</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如上面的一串数组a，b，c，d，如果在b，c中间插入一个e</p><p><strong>如果 key 绑定的是 index</strong> ；</p><p>那么除了a，b没有被改变之外，c，d的index发生了变化，所以c和d也都要重新渲染一遍，<strong>影响了性能</strong>。</p><p>原理如图：</p><p><img src="https://alanni-1.github.io/blog/img/twe/03.png"></p><h2 id="React中的key"><a href="#React中的key" class="headerlink" title="React中的key"></a>React中的key</h2><p>React中如果没有指定 key 也会<code>进行警告</code>，和 Vue 为了提升渲染性能，在内部维持了一个虚拟dom，当渲染结构有所变化的时候，会在虚拟dom中先用diff算法先进行一次对比，将所有的差异化解决之后，再一次性根据虚拟dom的变化，渲染到真实的dom结构中。</p><div class="note info flat"><p>key值是唯一的不建议使用 index 值。原理同上</p></div><p>简单示例，了解一下。等同于 Vue </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import React, &#123;Component&#125; from &#x27;react&#x27;;</span><br><span class="line">class Test extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            testArray: [&#123;text: &#x27;组件1&#x27;, id: &#x27;a&#x27;&#125;, &#123;text: &#x27;组件2&#x27;, id: &#x27;b&#x27;&#125;, &#123;text: &#x27;组件3&#x27;, id: &#x27;c&#x27;&#125;, &#123;text: &#x27;组件4&#x27;, id: &#x27;d&#x27;&#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //修改state打乱顺序</span><br><span class="line">    sort()&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            testArray: [&#123;text: &#x27;组件1&#x27;, id: &#x27;a&#x27;&#125;, &#123;text: &#x27;组件3&#x27;, id: &#x27;c&#x27;&#125;, &#123;text: &#x27;组件2&#x27;, id: &#x27;b&#x27;&#125;, &#123;text: &#x27;组件4&#x27;, id: &#x27;d&#x27;&#125;]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;div&gt;不指定key属性&lt;/div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.state.testArray.map((item) =&gt; &#123;</span><br><span class="line">                        return &lt;li &gt;&lt;span&gt;&#123;item.text&#125;&lt;/span&gt;&lt;input/&gt;&lt;/li&gt;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;div&gt;指定key属性&lt;/div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.state.testArray.map((item) =&gt; &#123;</span><br><span class="line">                        return &lt;li key=&#123;item.id&#125;&gt;&lt;span&gt;&#123;item.text&#125;&lt;/span&gt;&lt;input/&gt;&lt;/li&gt;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;button onClick=&#123;::this.sort&#125;&gt;打乱排序&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">export default Test</span><br></pre></td></tr></table></figure><p><strong>打乱前在iput中填入相应内容</strong></p><p><img src="https://alanni-1.github.io/blog/img/twe/04.png"></p><p><strong>打乱顺序后</strong></p><p><img src="https://alanni-1.github.io/blog/img/twe/05.png"></p><p>我们可以观察一下，打乱顺序后，如果我们不指定key属性，列表中组件的标题打乱了，但是 input 里面的内容还是没有变，这是因为没有指定 key 打乱标题后重新对标题进行的渲染赋值。而指定了 kye 值且是<code>唯一的</code>时，React通过diff算法会根据 key 来进行匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var、let和const 的区别和实现原理</title>
      <link href="/blog/2021/07/15/one/"/>
      <url>/blog/2021/07/15/one/</url>
      
        <content type="html"><![CDATA[<p>es6里面新增了两个声明变量的方法，一个是let，用于声明变量。一个是const，用于声明常量。var、let和const的区别经常会被面试官问到，大多数人都可能回答的是作用域和变量提升这两方面的不同，但你们知道内在原理吗？</p><p>下面我们就从<code>声明过程</code>、<code>内存分配</code>和<code>变量提升</code>三个方面来看一下这三者之间的区别。</p><h2 id="声明过程"><a href="#声明过程" class="headerlink" title="声明过程"></a>声明过程</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>遇到有var的作用域,在任何语句执行前都已经完成了<code>声明和初始化</code>，也就是变量提升而且拿到undefined的原因由来。</p><div class="note primary modern"><p>通过下面示例可以看到变量a的声明跑到console.log的前面去了，只是赋值还是在console.log之后进行赋值的，console.log得到的结果就是undefined. 这就是所谓的变量提升了。</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量提升后</span></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">// 声明并初始化</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a未赋值返回undefined</span></span><br><span class="line">a = <span class="number">10</span>; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>解析器进入一个<code>块级作用域</code>,发现let关键字，变量<code>只是先完成声明</code>,并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是<code>暂时性死区</code>的由来。等到解析到有let那一行的时候,才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行。</p><div class="note danger flat"><p>let初始化赋值之前访问，就会报错未定义变量</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const、class都是同let—样的道理。const声明的是一个常量，常量是<code>不可修改</code>的，在没有完成初始化和赋值操作是访问会报错，<code>不能重复声明</code>同一个常量。</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="var-1"><a href="#var-1" class="headerlink" title="var"></a>var</h3><p>var的话，会直接在栈内存里预分配内存空间,然后等到实际语句执行的时候,再存储对应的变量,如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针</p><h3 id="let-1"><a href="#let-1" class="headerlink" title="let"></a>let</h3><p>let的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时,做一个检查,如果已经有相同变量名存在就会报错 Identifier ‘变量’ has already been declared</p><div class="note danger flat"><p>如果用let重复声明同一个变量，那么这时候就会报错：变量b已经被声明了</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;<span class="comment">//error : Identifier &#x27;b&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h3 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h3><p>const的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是<code>不可修改</code>的，对于基本类型来说你无法修改定义的值,对于引用类型来说你无法修改栈内存里分配的指针,但是你可以修改指针指向的对象里面的属性</p><div class="note danger flat"><p>const声明的常量是不可以直接更改的，一旦你尝试着去修改一个常量的时候，浏览器就会告诉你，常量不可以被修改！</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">3.1415926</span>;</span><br><span class="line">c = <span class="number">123</span>;<span class="comment">//error : Assignment to constant variable</span></span><br></pre></td></tr></table></figure><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>let const和var三者其实会存在变量提升</p><p>let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。</p><p>var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined</p><p>function的创建、初始化、赋值都被提升了</p><div class="note info modern"><p>function：声明、初始化、赋值一开始就全部完成,所以函数的变量提升优先级更高。</p></div>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2021/06/04/hello-world/"/>
      <url>/blog/2021/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
